<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A simple, humane, typed key-value storage solution. It supports multiple backend engines with varying guarantees, such as LMDB for performance, or “SafeMode” for reliability."><title>rkv - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rkv" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0 (051478957 2024-07-21)" data-channel="1.80.0" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../rkv/index.html">rkv</a><span class="version">0.19.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">rkv</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/rkv/lib.rs.html#10-236">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A simple, humane, typed key-value storage solution. It supports multiple backend
engines with varying guarantees, such as <a href="http://www.lmdb.tech/doc/">LMDB</a> for
performance, or “SafeMode” for reliability.</p>
<p>It aims to achieve the following:</p>
<ul>
<li>Avoid sharp edges (e.g., obscure error codes for common situations).</li>
<li>Correctly restrict access to one handle per process via a
<a href="struct.Manager.html">Manager</a>.</li>
<li>Use Rust’s type system to make single-typed key stores safe and ergonomic.</li>
<li>Encode and decode values via <a href="https://docs.rs/bincode/">bincode</a>/<a href="https://docs.rs/serde/">serde</a>
and type tags, achieving platform-independent storage and input/output flexibility.</li>
</ul>
<p>It exposes these primary abstractions:</p>
<ul>
<li><a href="struct.Manager.html">Manager</a>: a singleton that controls access to environments</li>
<li><a href="struct.Rkv.html">Rkv</a>: an environment contains a set of key/value databases</li>
<li><a href="store/single/struct.SingleStore.html">SingleStore</a>: a database contains a set of
key/value pairs</li>
</ul>
<p>Keys can be anything that implements <code>AsRef&lt;[u8]&gt;</code> or integers
(when accessing an <a href="store/integer/struct.IntegerStore.html">IntegerStore</a>).</p>
<p>Values can be any of the types defined by the <a href="value/enum.Value.html">Value</a> enum,
including:</p>
<ul>
<li>booleans (<code>Value::Bool</code>)</li>
<li>integers (<code>Value::I64</code>, <code>Value::U64</code>)</li>
<li>floats (<code>Value::F64</code>)</li>
<li>strings (<code>Value::Str</code>)</li>
<li>blobs (<code>Value::Blob</code>)</li>
</ul>
<p>See <a href="value/enum.Value.html">Value</a> for the complete list of supported types.</p>
<h3 id="basic-usage"><a class="doc-anchor" href="#basic-usage">§</a>Basic Usage</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rkv::{Manager, Rkv, SingleStore, Value, StoreOptions};
<span class="kw">use </span>rkv::backend::{SafeMode, SafeModeEnvironment};
<span class="kw">use </span>std::fs;
<span class="kw">use </span>tempfile::Builder;

<span class="comment">// First determine the path to the environment, which is represented on disk as a
// directory containing two files:
//
//   * a data file containing the key/value stores
//   * a lock file containing metadata about current transactions
//
// In this example, we use the `tempfile` crate to create the directory.
//
</span><span class="kw">let </span>root = Builder::new().prefix(<span class="string">"simple-db"</span>).tempdir().unwrap();
fs::create_dir_all(root.path()).unwrap();
<span class="kw">let </span>path = root.path();

<span class="comment">// The `Manager` enforces that each process opens the same environment at most once by
// caching a handle to each environment that it opens. Use it to retrieve the handle
// to an opened environment—or create one if it hasn't already been opened:
</span><span class="kw">let </span><span class="kw-2">mut </span>manager = Manager::&lt;SafeModeEnvironment&gt;::singleton().write().unwrap();
<span class="kw">let </span>created_arc = manager.get_or_create(path, Rkv::new::&lt;SafeMode&gt;).unwrap();
<span class="kw">let </span>env = created_arc.read().unwrap();

<span class="comment">// Then you can use the environment handle to get a handle to a datastore:
</span><span class="kw">let </span>store = env.open_single(<span class="string">"mydb"</span>, StoreOptions::create()).unwrap();

{
    <span class="comment">// Use a write transaction to mutate the store via a `Writer`. There can be only
    // one writer for a given environment, so opening a second one will block until
    // the first completes.
    </span><span class="kw">let </span><span class="kw-2">mut </span>writer = env.write().unwrap();

    <span class="comment">// Keys are `AsRef&lt;[u8]&gt;`, while values are `Value` enum instances. Use the `Blob`
    // variant to store arbitrary collections of bytes. Putting data returns a
    // `Result&lt;(), StoreError&gt;`, where StoreError is an enum identifying the reason
    // for a failure.
    </span>store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"int"</span>, <span class="kw-2">&amp;</span>Value::I64(<span class="number">1234</span>)).unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"uint"</span>, <span class="kw-2">&amp;</span>Value::U64(<span class="number">1234_u64</span>)).unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"float"</span>, <span class="kw-2">&amp;</span>Value::F64(<span class="number">1234.0</span>.into())).unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"instant"</span>, <span class="kw-2">&amp;</span>Value::Instant(<span class="number">1528318073700</span>)).unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"boolean"</span>, <span class="kw-2">&amp;</span>Value::Bool(<span class="bool-val">true</span>)).unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"string"</span>, <span class="kw-2">&amp;</span>Value::Str(<span class="string">"Héllo, wörld!"</span>)).unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"json"</span>, <span class="kw-2">&amp;</span>Value::Json(<span class="string">r#"{"foo":"bar", "number": 1}"#</span>)).unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"blob"</span>, <span class="kw-2">&amp;</span>Value::Blob(<span class="string">b"blob"</span>)).unwrap();

    <span class="comment">// You must commit a write transaction before the writer goes out of scope, or the
    // transaction will abort and the data won't persist.
    </span>writer.commit().unwrap();
}

{
    <span class="comment">// Use a read transaction to query the store via a `Reader`. There can be multiple
    // concurrent readers for a store, and readers never block on a writer nor other
    // readers.
    </span><span class="kw">let </span>reader = env.read().expect(<span class="string">"reader"</span>);

    <span class="comment">// Keys are `AsRef&lt;u8&gt;`, and the return value is `Result&lt;Option&lt;Value&gt;, StoreError&gt;`.
    </span><span class="macro">println!</span>(<span class="string">"Get int {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"int"</span>).unwrap());
    <span class="macro">println!</span>(<span class="string">"Get uint {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"uint"</span>).unwrap());
    <span class="macro">println!</span>(<span class="string">"Get float {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"float"</span>).unwrap());
    <span class="macro">println!</span>(<span class="string">"Get instant {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"instant"</span>).unwrap());
    <span class="macro">println!</span>(<span class="string">"Get boolean {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"boolean"</span>).unwrap());
    <span class="macro">println!</span>(<span class="string">"Get string {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"string"</span>).unwrap());
    <span class="macro">println!</span>(<span class="string">"Get json {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"json"</span>).unwrap());
    <span class="macro">println!</span>(<span class="string">"Get blob {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"blob"</span>).unwrap());

    <span class="comment">// Retrieving a non-existent value returns `Ok(None)`.
    </span><span class="macro">println!</span>(<span class="string">"Get non-existent value {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"non-existent"</span>).unwrap());

    <span class="comment">// A read transaction will automatically close once the reader goes out of scope,
    // so isn't necessary to close it explicitly, although you can do so by calling
    // `Reader.abort()`.
</span>}

{
    <span class="comment">// Aborting a write transaction rolls back the change(s).
    </span><span class="kw">let </span><span class="kw-2">mut </span>writer = env.write().unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"foo"</span>, <span class="kw-2">&amp;</span>Value::Str(<span class="string">"bar"</span>)).unwrap();
    writer.abort();
    <span class="kw">let </span>reader = env.read().expect(<span class="string">"reader"</span>);
    <span class="macro">println!</span>(<span class="string">"It should be None! ({:?})"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"foo"</span>).unwrap());
}

{
    <span class="comment">// Explicitly aborting a transaction is not required unless an early abort is
    // desired, since both read and write transactions will implicitly be aborted once
    // they go out of scope.
    </span>{
        <span class="kw">let </span><span class="kw-2">mut </span>writer = env.write().unwrap();
        store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"foo"</span>, <span class="kw-2">&amp;</span>Value::Str(<span class="string">"bar"</span>)).unwrap();
    }
    <span class="kw">let </span>reader = env.read().expect(<span class="string">"reader"</span>);
    <span class="macro">println!</span>(<span class="string">"It should be None! ({:?})"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"foo"</span>).unwrap());
}

{
    <span class="comment">// Deleting a key/value pair also requires a write transaction.
    </span><span class="kw">let </span><span class="kw-2">mut </span>writer = env.write().unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"foo"</span>, <span class="kw-2">&amp;</span>Value::Str(<span class="string">"bar"</span>)).unwrap();
    store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"bar"</span>, <span class="kw-2">&amp;</span>Value::Str(<span class="string">"baz"</span>)).unwrap();
    store.delete(<span class="kw-2">&amp;mut </span>writer, <span class="string">"foo"</span>).unwrap();

    <span class="comment">// A write transaction also supports reading, and the version of the store that it
    // reads includes the changes it has made regardless of the commit state of that
    // transaction.
    // In the code above, "foo" and "bar" were put into the store, then "foo" was
    // deleted so only "bar" will return a result when the database is queried via the
    // writer.
    </span><span class="macro">println!</span>(<span class="string">"It should be None! ({:?})"</span>, store.get(<span class="kw-2">&amp;</span>writer, <span class="string">"foo"</span>).unwrap());
    <span class="macro">println!</span>(<span class="string">"Get bar ({:?})"</span>, store.get(<span class="kw-2">&amp;</span>writer, <span class="string">"bar"</span>).unwrap());

    <span class="comment">// But a reader won't see that change until the write transaction is committed.
    </span>{
        <span class="kw">let </span>reader = env.read().expect(<span class="string">"reader"</span>);
        <span class="macro">println!</span>(<span class="string">"Get foo {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"foo"</span>).unwrap());
        <span class="macro">println!</span>(<span class="string">"Get bar {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"bar"</span>).unwrap());
    }
    writer.commit().unwrap();
    {
        <span class="kw">let </span>reader = env.read().expect(<span class="string">"reader"</span>);
        <span class="macro">println!</span>(<span class="string">"It should be None! ({:?})"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"foo"</span>).unwrap());
        <span class="macro">println!</span>(<span class="string">"Get bar {:?}"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"bar"</span>).unwrap());
    }

    <span class="comment">// Committing a transaction consumes the writer, preventing you from reusing it by
    // failing at compile time with an error. This line would report "error[E0382]:
    // borrow of moved value: `writer`".
    // store.put(&amp;mut writer, "baz", &amp;Value::Str("buz")).unwrap();
</span>}

{
    <span class="comment">// Clearing all the entries in the store with a write transaction.
    </span>{
        <span class="kw">let </span><span class="kw-2">mut </span>writer = env.write().unwrap();
        store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"foo"</span>, <span class="kw-2">&amp;</span>Value::Str(<span class="string">"bar"</span>)).unwrap();
        store.put(<span class="kw-2">&amp;mut </span>writer, <span class="string">"bar"</span>, <span class="kw-2">&amp;</span>Value::Str(<span class="string">"baz"</span>)).unwrap();
        writer.commit().unwrap();
    }

    {
        <span class="kw">let </span><span class="kw-2">mut </span>writer = env.write().unwrap();
        store.clear(<span class="kw-2">&amp;mut </span>writer).unwrap();
        writer.commit().unwrap();
    }

    {
        <span class="kw">let </span>reader = env.read().expect(<span class="string">"reader"</span>);
        <span class="macro">println!</span>(<span class="string">"It should be None! ({:?})"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"foo"</span>).unwrap());
        <span class="macro">println!</span>(<span class="string">"It should be None! ({:?})"</span>, store.get(<span class="kw-2">&amp;</span>reader, <span class="string">"bar"</span>).unwrap());
    }

}
</code></pre></div>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.DatabaseFlags"><code>pub use backend::<a class="enum" href="backend/enum.DatabaseFlags.html" title="enum rkv::backend::DatabaseFlags">DatabaseFlags</a>;</code></div></li><li><div class="item-name" id="reexport.EnvironmentFlags"><code>pub use backend::<a class="enum" href="backend/enum.EnvironmentFlags.html" title="enum rkv::backend::EnvironmentFlags">EnvironmentFlags</a>;</code></div></li><li><div class="item-name" id="reexport.WriteFlags"><code>pub use backend::<a class="enum" href="backend/enum.WriteFlags.html" title="enum rkv::backend::WriteFlags">WriteFlags</a>;</code></div></li><li><div class="item-name" id="reexport.Migrator"><code>pub use migrator::<a class="struct" href="migrator/struct.Migrator.html" title="struct rkv::migrator::Migrator">Migrator</a>;</code></div></li><li><div class="item-name" id="reexport.EncodableKey"><code>pub use store::keys::<a class="trait" href="store/keys/trait.EncodableKey.html" title="trait rkv::store::keys::EncodableKey">EncodableKey</a>;</code></div></li><li><div class="item-name" id="reexport.SingleStore"><code>pub use store::single::<a class="struct" href="store/single/struct.SingleStore.html" title="struct rkv::store::single::SingleStore">SingleStore</a>;</code></div></li><li><div class="item-name" id="reexport.CloseOptions"><code>pub use store::<a class="struct" href="store/struct.CloseOptions.html" title="struct rkv::store::CloseOptions">CloseOptions</a>;</code></div></li><li><div class="item-name" id="reexport.StoreOptions"><code>pub use store::<a class="struct" href="store/struct.Options.html" title="struct rkv::store::Options">Options</a> as StoreOptions;</code></div></li><li><div class="item-name" id="reexport.OwnedValue"><code>pub use value::<a class="enum" href="value/enum.OwnedValue.html" title="enum rkv::value::OwnedValue">OwnedValue</a>;</code></div></li><li><div class="item-name" id="reexport.Value"><code>pub use value::<a class="enum" href="value/enum.Value.html" title="enum rkv::value::Value">Value</a>;</code></div></li><li><div class="item-name" id="reexport.MultiStore"><code>pub use store::multi::<a class="struct" href="store/multi/struct.MultiStore.html" title="struct rkv::store::multi::MultiStore">MultiStore</a>;</code></div></li><li><div class="item-name" id="reexport.IntegerStore"><code>pub use store::integer::<a class="struct" href="store/integer/struct.IntegerStore.html" title="struct rkv::store::integer::IntegerStore">IntegerStore</a>;</code></div></li><li><div class="item-name" id="reexport.PrimitiveInt"><code>pub use store::keys::<a class="trait" href="store/keys/trait.PrimitiveInt.html" title="trait rkv::store::keys::PrimitiveInt">PrimitiveInt</a>;</code></div></li><li><div class="item-name" id="reexport.MultiIntegerStore"><code>pub use store::integermulti::<a class="struct" href="store/integermulti/struct.MultiIntegerStore.html" title="struct rkv::store::integermulti::MultiIntegerStore">MultiIntegerStore</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="backend/index.html" title="mod rkv::backend">backend</a></div></li><li><div class="item-name"><a class="mod" href="migrator/index.html" title="mod rkv::migrator">migrator</a></div><div class="desc docblock-short">A simple utility for migrating data from one RVK environment to another. Notably, this
tool can migrate data from an enviroment created with a different backend than the
current RKV consumer (e.g from Lmdb to SafeMode).</div></li><li><div class="item-name"><a class="mod" href="store/index.html" title="mod rkv::store">store</a></div></li><li><div class="item-name"><a class="mod" href="value/index.html" title="mod rkv::value">value</a></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Manager.html" title="struct rkv::Manager">Manager</a></div><div class="desc docblock-short">A process is only permitted to have one open handle to each Rkv environment. This
manager exists to enforce that constraint: don’t open environments directly.</div></li><li><div class="item-name"><a class="struct" href="struct.Reader.html" title="struct rkv::Reader">Reader</a></div></li><li><div class="item-name"><a class="struct" href="struct.Rkv.html" title="struct rkv::Rkv">Rkv</a></div><div class="desc docblock-short">Wrapper around an <code>Environment</code> (e.g. such as an <code>LMDB</code> or <code>SafeMode</code> environment).</div></li><li><div class="item-name"><a class="struct" href="struct.Writer.html" title="struct rkv::Writer">Writer</a></div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.DataError.html" title="enum rkv::DataError">DataError</a></div></li><li><div class="item-name"><a class="enum" href="enum.MigrateError.html" title="enum rkv::MigrateError">MigrateError</a></div></li><li><div class="item-name"><a class="enum" href="enum.StoreError.html" title="enum rkv::StoreError">StoreError</a></div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Readable.html" title="trait rkv::Readable">Readable</a></div></li></ul></section></div></main></body></html>